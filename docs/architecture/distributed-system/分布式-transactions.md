> 本文来自JavaGuide，郎涯进行简单排版与补充



## 事务

我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：

- 数据库中途突然因为某些原因挂掉了。
- 客户端突然因为网络原因连接不上数据库了。

- 并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。
- ......

上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。



**何为事务？** 一言蔽之，**事务是逻辑上的一组操作，要么都执行，要么都不执行。**



事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。

1. 将小明的余额减少 1000 元
2. 将小红的余额增加 1000 元。



事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。

![img](https://img-note.langyastudio.com/202202201411858.png?x-oss-process=style/watermark)



## 数据库事务

大多数情况下，我们在谈论事务的时候，如果没有特指**分布式事务**，往往指的就是**数据库事务**。

数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。



**那数据库事务有什么作用呢？**

简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功,要么全部不执行** 。

```sql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```

![img](https://img-note.langyastudio.com/202202201415225.png?x-oss-process=style/watermark)



另外，关系型数据库（例如：`MySQL`、`SQL Server`、`Oracle` 等）事务都有 **ACID** 特性：

![img](https://img-note.langyastudio.com/202202201415488.png?x-oss-process=style/watermark)



1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durabilily`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



🌈 这里要额外补充一点：**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！** 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课[《周志明的软件架构课》](https://time.geekbang.org/opencourse/intro/100064201)才搞清楚的（多看好书！！！）。

![img](https://img-note.langyastudio.com/202202201415943.png?x-oss-process=style/watermark)



另外，DDIA 也就是 [《Designing Data-Intensive Application（数据密集型应用系统设计）》](https://book.douban.com/subject/30329536/) 的作者在他的这本书中如是说：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。



**数据事务的实现原理呢？**

我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 `**REPEATABLE-READ**`）。



## 分布式事务

微服务架构下，一个系统被拆分为多个小的微服务。每个微服务都可能存在不同的机器上，并且每个微服务可能都有一个单独的数据库供自己使用。这种情况下，一组操作可能会涉及到多个微服务以及多个数据库。举个例子：电商系统中，你创建一个订单往往会涉及到订单服务（订单数加一）、库存服务（库存减一）等等服务，这些服务会有供自己单独使用的数据库。

![img](https://img-note.langyastudio.com/202202201415960.png?x-oss-process=style/watermark)



**那么如何保证这一组操作要么都执行成功，要么都执行失败呢？**

这个时候单单依靠数据库事务就不行了！我们就需要引入 **分布式事务** 这个概念了！

实际上，只要跨数据库的场景都需要用到引入分布式事务。比如说单个数据库的性能达到瓶颈或者数据量太大的时候，我们需要进行 **分库**。分库之后，同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。

![img](https://img-note.langyastudio.com/202202201415227.png?x-oss-process=style/watermark)



一言蔽之，**分布式事务的终极目标就是保证系统中多个相关联的数据库中的数据的一致性！**

那既然分布式事务也属于事务，理论上就应该准守事物的 ACID 四大特性。但是，考虑到性能、可用性等各方面因素，我们往往是无法完全满足 ACID 的，只能选择一个比较折中的方案。

针对分布式事务，又诞生了一些新的理论。



## 分布式事务基础理论

### CAP 理论和 BASE 理论

CAP 理论和 BASE 理论是分布式领域非常非常重要的两个理论。不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。

不论是你面试也好，工作也罢，都非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。



### 一致性的 3 种级别

我们可以把对于系统一致性的要求分为下面 3 种级别：

![img](https://img-note.langyastudio.com/202202201415198.png?x-oss-process=style/watermark)



1. **强一致性** ：系统写入了什么，读出来的就是什么。
2. **弱一致性** ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。
3. **最终一致性** ：弱一致性的升级版。系统会保证**在一定时间内**达到数据一致的状态，

业界比较推崇是 **最终一致性**，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。



### 柔性事务

互联网应用最关键的就是要保证高可用， 计算式系统几秒钟之内没办法使用都有可能造成数百万的损失。在此场景下，一些大佬们在 CAP 理论和 BASE 理论的基础上，提出了 **柔性事务** 的概念。 **柔性事务追求的是最终一致性。**

实际上，柔性事务就是 **BASE 理论 +业务实践**。 柔性事务追求的目标是：我们根据自身业务特性，通过适当的方式来保证系统数据的最终一致性。 像 **TCC**、 **Saga**、**MQ 事务** 、**本地消息表** 就属于柔性事务。



### 刚性事务

与柔性事务相对的就是 **刚性事务** 了。前面我们说了，**柔性事务追求的是最终一致性** 。那么，与之对应，刚性事务追求的就是 **强一致性**。像**2PC** 、**3PC** 就属于刚性事务。

![img](https://img-note.langyastudio.com/202202201415187.png?x-oss-process=style/watermark)



## 分布式事务解决方案

分布式事务的解决方案有很多，比如：**2PC**、**3PC**、**TCC**、**本地消息表**、**MQ 事务**（Kafka 和 RocketMQ 都提供了事务相关功能） 、**Saga** 等等。这些方案的适用场景有所区别，我们需要根据具体的场景选择适合自己项目的解决方案。



### 2PC（两阶段提交协议）

2PC（Two-Phase Commit）这三个字母的含义:

- **2** -> 指代事务提交的 2 个阶段
- **P**-> Prepare (准备阶段)

- **C** ->Commit（提交阶段）

2PC 将事务的提交过程分为 2 个阶段：**准备阶段** 和 **提交阶段** 。



#### 准备阶段(Prepare)

准备阶段的核心是“询问”事务参与者执行本地数据库事务操作是否成功。

1. **事务协调者/管理者** 向所有参与者发送消息询问：“你是否可以执行事务操作呢？”，并等待其答复。
2. **事务参与者** 接收到消息之后，开始执行本地数据库事务预操作比如写 redo log/undo log 日志。但是 ，此时并不会提交事务！
3. **事务参与者** 如果执行本地数据库事务操作成功，那就回复：“就绪”，否则就回复：“未就绪”。



#### 提交阶段(Commit)

提交阶段的核心是“询问”事务参与者提交事务是否成功。

当所有事务参与者都是“就绪”状态的话：

1. **事务协调者/管理者** 向所有参与者发送消息：“你们可以提交事务啦！”（**commit 消息**）
2. **事务参与者** 接收到 **commit 消息** 后执行 **提交本地数据库事务** 操作，执行完成之后 **释放整个事务期间所占用的资源**。
3. **事务参与者** 回复：“事务已经提交” （**ack 消息**）。
4. **事务协调者/管理者** 收到所有 **事务参与者** 的 **ack 消息** 之后，整个分布式事务过程正式结束。

![img](https://img-note.langyastudio.com/202202201415888.png?x-oss-process=style/watermark)



当任一事务参与者是“未就绪”状态的话：

1. **事务协调者/管理者** 向所有参与者发送消息：“你们可以执行回滚操作了！”（**rollback 消息**）。
2. 务参与者** 接收到 **rollback 消息** 后执行 **本地数据库事务回滚** 执行完成之后 **释放整个事务期间所占用的资源**。
3. **事务参与者** 回复：“事务已经回滚” （**ack 消息**）。
4. **事务协调者/管理者** 收到所有 **事务参与者** 的 **ack 消息** 之后，取消事务。

![img](https://img-note.langyastudio.com/202202201416848.png?x-oss-process=style/watermark)



#### 总结

简单总结一下 **2PC** 两阶段中比较重要的一些点：

1. **准备阶段** 的主要目的是测试 **事务参与者** 能否执行 **本地数据库事务** 操作（!!!注意：这一步并不会提交事务）。
2. **提交阶段** 中 **事务协调者/管理者** 会根据 **准备阶段** 中 **事务参与者** 的消息来决定是执行事务提交还是回滚操作。
3. **提交阶段** 之后一定会结束当前的分布式事务



**2PC 的优点：**

- 实现起来非常简单，各大主流数据库比如 MySQL、Oracle 都有自己实现。
- 针对的是数据强一致性。不过，仍然可能存在数据不一致的情况。



**2PC 存在的问题：**

- **同步阻塞** ：事务参与者会在正式提交事务之前会一直占用相关的资源。比如用户小明转账给小红，那其他事务也要操作用户小明或小红的话，就会阻塞。
- **数据不一致** ：由于网络问题或者事务协调者/管理者宕机都有可能会造成数据不一致的情况。比如在第2阶段（提交阶段），部分网络出现问题导致部分参与者收不到 commit/rollback 消息的话，就会导致数据不一致。

- **单点问题** ： 事务协调者/管理者在其中也是一个很重要的角色，如果事务协调者/管理者在准备(Prepare)阶段完成之后挂掉的话，事务参与者就会一直卡在提交(Commit)阶段。



### 3PC（三阶段提交协议）

3PC 是人们在 2PC 的基础上做了一些优化得到的。3PC 把 2PC 中的 **准备阶段(Prepare)** 做了进一步细化，分为 2 个阶段：

- **询问阶段(CanCommit)** ：这一步 不会执行事务操作，只会询问事务参与者能否执行本地数据库事操作。
- **准备阶段(PreCommit)** ：当所有事物参与者都返回“可执行”之后， 事务参与者才会执行本地数据库事务预操作比如写 redo log/undo log 日志。

![img](https://img-note.langyastudio.com/202202201434458.png?x-oss-process=style/watermark)

除此之外，3PC 还引入了 **超时机制 来避免事务参与者一直阻塞占用资源** 。



### TCC（补偿事务）

TCC 属于目前比较火的一种柔性事务解决方案。TCC 这个概念最早诞生于数据库专家帕特 · 赫兰德（Pat Helland）于 2007 发表的 [《Life beyond Distributed Transactions: an Apostate’s Opinion》](https://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf) 这篇论文，感兴趣的小伙伴可以阅读一下这篇论文。

#### 三个阶段

简单来说，TCC 是 Try、Confirm、Cancel 三个词的缩写，它分为三个阶段：

- **Try（尝试）阶段** : 尝试执行

完成业务检查，并**预留好必需的业务资源**。

- **Confirm（确认）阶段** ：确认执行

当所有事务参与者的 Try 阶段执行成功就会执行 Confirm ，Confirm 阶段会处理 Try 阶段预留的业务资源。否则，就会执行 Cancel 。

通常情况下，采用 TCC 则认为 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。若 Confirm 阶段真的出错了，需引入重试机制或人工处理。

- **Cancel（取消）阶段** ：取消执行，**释放 Try 阶段预留的业务资源**

通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。



#### TM 事务管理器

- TM 事务管理器可以实现为独立的服务，也可以让全局事务发起方充当 TM 的角色，TM 独立出来是为了成为公共组件，是为了考虑系统结构和软件复用
- TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于 Confirm 和 Cancel 失败需要重试，因此需要实现**幂等性**，幂等性是指同一个操作无论请求多少次，其结果都相同



#### 示例介绍

我们拿转账场景来说：

- **Try（尝试）阶段** : 在转账场景下，Try 要做的事情是就是检查账户余额是否充足，**预留的资源**就是转账资金

- **Confirm（确认）阶段** ： 如果 Try 阶段执行成功的话，Confirm 阶段就会执行真正的扣钱操作

- **Cancel（取消）阶段** ：释放 Try 阶段预留的转账资金

一般情况下，当我们使用 `TCC` 模式的时候,需要自己实现 `try`, `confirm`, `cancel` 这三个方法，来达到最终一致性。也就是说，**正常情况下会执行 `try`, `confirm`**，如下图所示。

![img](https://img-note.langyastudio.com/202202201434985.png?x-oss-process=style/watermark)



**出现异常的话会执行 `try`, `cancel`** ，如下图所示。

![img](https://img-note.langyastudio.com/202202201434242.png?x-oss-process=style/watermark)

因此，**TCC 模式不需要依赖于底层数据资源的事务支持，但是需要我们手动实现更多的代码**，属于 **侵入业务代码** 的一种分布式解决方案。

针对 TCC 的实现，业界也有一些不错的开源框架。不同的框架对于 TCC 的实现可能略有不同，不过大致思想都一样。

1. [**ByteTCC**](https://github.com/liuyangming/ByteTCC) : ByteTCC 是基于 Try-Confirm-Cancel（TCC）机制的分布式事务管理器的实现。 相关阅读：[关于如何实现一个 TCC 分布式事务框架的一点思考](https://www.bytesoft.org/how-to-impl-tcc/)
2. [**Seata**](https://seata.io/zh-cn/index.html) :Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。

1. [**Hmily**](https://github.com/dromara/hmily) : 金融级分布式事务解决方案。



#### 空回滚、幂等、悬挂

**空回滚：**

- 在没调用 Try 方法的情况下，调用了第二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功
- 出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行 Try 阶段，当故障恢复后，分布式事务进行回滚则会调用第二阶段的 Cacel 方法，从而形成空回滚
- 解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚。如果没有执行，那就是空回滚。前面已经说过 TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条。再额外增加一张**分支事务记录表**，其中有全局事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚

**幂等：**

- 通过前面介绍已经了解到，为了保证 TCC 二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、Confirm 和 Cancel 接口保证幂等，这样**不会重复使用或者释放资源**。如果幂等控制没有做好，很有可能导致数据不一致等严重问题
- 解决思路在上述“**分支事务记录**”中增加执行状态，每次执行前都查询该状态

**悬挂：**

- 悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行
- 出现原因是在 RPC 调用分支事务 try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个 Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就成为悬挂，即业务资源预留后没法继续处理
- 解决思路时候如果二阶段执行完成，那一阶段就不能再继续执行。再执行一阶段事务时判断在该全局事务下，“**分支事务记录**”表中是否已经有二阶段事务记录，如果有则不执行 Try



#### TCC vs 2PC

2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的颗粒度，使得降低锁冲突、让提高吞吐量成为可能。



### MQ 事务

> RocketMQ 主要解决了两个功能：
>
> 1. **本地事务与消息发送的原子性问题**
> 2. **事务参与方接收消息的可靠性**
>
> 早期是通过本地消息表解决

RocketMQ 、 Kafka、Pulsar 、QMQ都提供了事务相关的功能。事务允许事件流应用将消费，处理，生产消息整个过程定义为一个原子操作。

这里我们拿 RocketMQ 来说（图源：《消息队列高手课》）。相关阅读：[RocketMQ 事务消息参考文档](https://rocketmq.apache.org/docs/transaction-example/) 。

![img](https://img-note.langyastudio.com/202202201434054.png?x-oss-process=style/watermark)



1. MQ 发送方（比如物流服务）在消息队列上开启一个事务，然后发送一个“半消息”给 MQ Server/Broker。事务提交之前，半消息对于 MQ 订阅方/消费者（比如第三方通知服务）不可见
2. “半消息”发送成功的话，MQ 发送方就开始执行本地事务。
3. MQ 发送方的本地事务执行成功的话，“半消息”变成正常消息，可以正常被消费。MQ 发送方的本地事务执行失败的话，会直接回滚。

从上面的流程中可以看出，**MQ 的事务消息使用的是两阶段提交**（2PC），简单来说就是咱先发送半消息，等本地事务执行成功之后，半消息才变为正常消息。



**如果 MQ 发送方提交或者回滚事务消息时失败怎么办？**

RocketMQ 中的 Broker 会定期去 MQ 发送方上反查这个事务的本地事务的执行情况，并根据反查结果决定提交或者回滚这个事务。

事务反查机制的实现依赖于我们业务代码实现的对应的接口，比如你要查看创建物流信息的本地事务是否执行成功的话，直接在数据库中查询对应的物流信息是否存在即可。

![img](https://img-note.langyastudio.com/202202201434246.png?x-oss-process=style/watermark)



**如果正常消息没有被正确消费怎么办呢？**

消息消费失败的话，RocketMQ 会自动进行消费重试。如果超过最大重试次数这个消息还是没有正确消费，RocketMQ 就会认为这个消息有问题，然后将其放到 **死信队列**。

![img](https://img-note.langyastudio.com/202202201434491.png?x-oss-process=style/watermark)



进入死信队列的消费一般需要人工处理，手动排查问题。

RocketMQ 的事务消息方案中，如果消息队列挂掉，数据库事务就无法执行了，整个应用也就挂掉了。

相关阅读： [面试官：RocketMQ 分布式事务消息的缺点？](https://mp.weixin.qq.com/s/cBx1l1zaThN6_808fMl27g)



## 分布式事务对比分析

- 2PC 最大的诟病是一个阻塞协议。RM 在执行分支事务后需要等待 TM 的决定，此时服务会阻塞并锁定资源。由于其阻塞机制和最差时间复杂度较高，因此这种设计不能适应随着事务涉及的服务数量增加而扩展的需要，**很难用于并发较高**以及子事务生命周期较长的分布式服务中
- 如果拿 TCC 事务的处理流程与 2PC 作比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的颗粒度，使得降低锁冲突、提交吞吐量成为可能。而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的原因实现不同的回滚策略。典型的使用场景，**登录之后送优惠券**
- 可靠消息最终一致性事务适合执行**周期长**且**实时性要求不高**的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。典型的使用场景：**注册送积分、登录送优惠券**等
- 最大努力通知是分布式事务中要求最低的一种，适用于一些最终一致性时间敏感度较低的业务；允许发起通知方处理业务失败，在接收通知方收到通知后积极进行失败处理，无论发起通知方如何处理结果都不会影响到接收通知方的后续处理；发起通知方需要**提供查询执行情况接口**，用于接收通知方校对结果。典型的使用场景：**银行通知、支付结果通知**等



## 推荐阅读

- [分布式事务理论](https://dtm.pub/practice/theory.html)
- [阿里终面：分布式事务原理](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247494827&idx=1&sn=aa5d7401d53b1ca61b5e49462262bd22&chksm=cea1a360f9d62a761dff15a682f69fcacdd5b70a8afc4e1114cc7f6704b31d9aa3ad82ae5233&token=2092405348&lang=zh_CN#rd)
- [微服务中的分布式事务方案](https://jeremyxu2010.github.io/2020/03/微服务中的分布式事务方案/#heading-3)

- [消息队列之事务消息，RocketMQ 和 Kafka 是如何做的？](https://juejin.cn/post/6867040340797292558)
- [聊一聊分布式事务](https://mp.weixin.qq.com/s/zp1kJ895zBb9vA7fgJ20eQ)
- [分布式事务（三）：分布式事务解决方案之TCC（Try、Confirm、Cancel）](https://blog.csdn.net/qq_42163058/article/details/123066568)
- [分布式事务（五）：分布式事务解决方案之最大努力通知](https://blog.csdn.net/qq_42163058/article/details/123192169)
